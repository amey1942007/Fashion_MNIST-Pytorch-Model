# -*- coding: utf-8 -*-
"""Fashion_MNIST.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17dFG6HE1Ko1Gpl1MqNocdr-8YEgtql_g

#========================================================================================================================================================== Import required Module and Library ==========================================================================================================================================================
"""

# Pytorch
import torch

# Datasets of Fashion MNIST
from torchvision import datasets

# import dataloader which creates an iterable around the dataset of 60,000 training and 10,000 testing data
from torch.utils.data import dataloader

#import pytorch neural network module for making custom layers
from torch import nn

# import a converter which converts the object into tensor (image---> tensor)
from torchvision.transforms import ToTensor

# data manupulating tools
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Randomization library
import random

# Get cpu or gpu device for training.
device = "cuda" if torch.cuda.is_available() else "cpu"

"""## Training data checks =========================================================================================================================================================="""

# importing data
train = datasets.FashionMNIST(root='data',train=True,download=True,transform=ToTensor())

# checking the data
train #60,000 samples for training
train.data.shape #is a tensor of (60000,28,28) # an image of 28*28 pixel

"""## Test data checks =========================================================================================================================================================="""

#importing the test data
test = datasets.FashionMNIST(root='data',train=False,download=True,transform=ToTensor())

# checking the data
test.data.shape # shows a tensor of (10000,28,28)

"""## Dataloader checks =========================================================================================================================================================="""

#splitting the dta into batches of 100
train_dataloader = dataloader.DataLoader(dataset=train,batch_size=100)
test_dataloader = dataloader.DataLoader(dataset=test,batch_size=100)

len(test_dataloader) # shows that we have sucess created a batch of 100

"""## Model construction =========================================================================================================================================================="""

# here we will create the neural network
class NeuralNetwork(nn.Module): # this nn.Module inherites the property of its super class by calling super().__Init__()
  def __init__(self) -> None:
    super().__init__() # as discussed earlier is  used for inheritance

    self.flatten = nn.Flatten() # Flattens

    self.linear_relu_stack = nn.Sequential(
        nn.Linear(in_features=784,out_features=512), # applies the linear transformationa and creates the first layer

        nn.ReLU(), # applies the rectified linear Unit to the output of the first layer to make the output in 0-1 range

        nn.Linear(in_features=512,out_features=512), # applies the linear transformationa and creates the second layer

        nn.ReLU(), # applies the rectified linear Unit to the output of the second layer to make the output in 0-1 range

        nn.Linear(in_features=512,out_features=10), # finally applies a linear transformation and predicts the category of clothes
        )

  def forward(self,x):
    flatten_input = self.flatten(x)

    #appling our neural network to the flatten input
    network = self.linear_relu_stack(flatten_input)

    return network # return the result

model = NeuralNetwork().to(device) # create the model

"""## =========================================================================================================================================================="""

loss = nn.CrossEntropyLoss() # we use cross Entropy loss because the output of our network in 10 (multiple)

optimiser = torch.optim.SGD(model.parameters(),lr=0.01) # create an optimiser to change the weight and bias and calculate gradient

"""## Function defining =========================================================================================================================================================="""

# here we define our training and test loops
def Training(dataloader,model,loss,optimiser):
  model.train() # set the model into training mode

  for batch_number , (x,y) in enumerate(dataloader):

    x, y = x.to(device), y.to(device) # transfer the data from device to gpu

    y_predicted = model(x) # calculate the predicted answer for the data

    l = loss(y_predicted,y) # calculate the loss

    optimiser.zero_grad() # set the gradient to zero

    l.backward() # calculate the derivative in the the backpropagation

    optimiser.step() # change the weight and bias according to the loss and learnig rate

    if batch_number%100==0:
      print(f'current loss: {l.item():.5f}  , batch number: {batch_number}') # print the status in every 100 batches

def Test(dataloader,model,loss):
  model.eval() # sets the model to eval and not to update the computational graph

  test_loss , correct = 0,0 # make a counter for the correct answer given an wrong answer given

  with torch.no_grad():
    for x,y in dataloader:
      x, y = x.to(device), y.to(device) # for testing move the data to gpu
      y_predicted = model(x)

      test_loss += loss(y_predicted,y).item()
      correct += (y_predicted.argmax(1)==y).type(torch.float).sum().item()

  test_loss /= len(dataloader) # calculate the average loss or wrong answer reported per batch

  correct /= 10000 # calculate the accuracy i.e,The amount of correct category guess by the model

  print(f'\n Test Evaluation result: \n Accuracy: {(correct*100):.2f},\n Avg loss:{test_loss:.3f}')

"""##         Training and Testing Loop ====================================================================================================================================================="""

n_epochs = 25 # number of times i want to run
for i in range(n_epochs):
  print(f"\n\n   Epoch {i+1}  -------------------- \n")

  Training(train_dataloader,model,loss,optimiser)
  Test(test_dataloader,model,loss)
print(f"Done!\n")

"""## Visualization =========================================================================================================================================================="""

labels = [
    "T-shirt/top",
    "Trouser",
    "Pullover",
    "Dress",
    "Coat",
    "Sandal",
    "Shirt",
    "Sneaker",
    "Bag",
    "Ankle boot",
]

# Get a single random index
random_idx = random.randint(0, 9999)

# Display the image from the chosen random index
plt.imshow(test.data[random_idx], cmap = "Greys")

# Get the pixel data (x) from the same random index
x = test[random_idx][0]
x = x.to(device)

# Get the true / correct label (y) from the same random index
y = test[random_idx][1]


with torch.no_grad():
    pred = model(x)                     # predict with model
    prediction = labels[pred[0].cpu().argmax(0)] # find predicted label
    truth      = labels[y]                 # true label

    print(f"simpleNN predict as {prediction} ; truth is {truth}")

"""## Saving the model's state dict =========================================================================================================================================================="""

# Define the path where you want to save the model's state_dict
model_save_path = "fashion_mnist_model_weights.pth"

# Save the model's state_dict
torch.save(model.state_dict(), model_save_path)

print(f"Model weights saved to {model_save_path}")

"""To load the saved weights, we first need to re-instantiate your model architecture, and then load the state dict into it. You should always load weights into a model that has the *same architecture* as the one that was saved."""

# First, create a new instance of your NeuralNetwork model
loaded_model = NeuralNetwork()

# Load the saved state_dict into the new model instance
loaded_model.load_state_dict(torch.load("fashion_mnist_model_weights.pth"))

# Set the model to evaluation mode if you're not planning to train it further
loaded_model.eval()

print("Model weights loaded successfully into 'loaded_model'.")
